<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <title>Cloze-Test (Minimal)</title>
    <style>
        body {
            font-family: system-ui, sans-serif;
            margin: 2rem;
            line-height: 1.6;
        }

        textarea {
            width: 100%;
            min-height: 140px;
        }

        input[type=number] {
            width: 80px;
        }

        .word {
            display: inline-block;
            margin: 0 4px;
        }

        .blank {
            width: 120px;
            padding: 2px 4px;
        }

        /* додано: окремий клас для інпутів під формули */
        .math-blank {
            width: 120px;
            padding: 2px 4px;
            margin: 2px 0;
        }

        .correct {
            background: palegreen;
        }

        .incorrect {
            background: lightcoral;
        }

        #controls {
            margin: 1rem 0;
        }

        /* формульні спани, щоб не ламати переноси */
        .formula {
            white-space: nowrap;
        }

        /* --- Зображення + маски --- */
        .row {
            display: flex;
            flex-wrap: wrap;
            gap: .75rem;
            align-items: center;
            margin: 1rem 0
        }

        #figures {
            display: grid;
            gap: 1rem;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr))
        }

        .figure {
            border: 1px solid #e4e4e4;
            border-radius: .5rem;
            padding: .5rem
        }

        .fig-head {
            font-weight: 600;
            margin-bottom: .35rem
        }

        .img-box {
            position: relative;
            overflow: hidden;
            background: #fafafa
        }

        .img-box img {
            display: block;
            max-width: 100%;
            height: auto
        }

        /* Прямокутні "дірки" (маски) */
        .mask {
            position: absolute;
            border: 2px dashed #777;
            background: rgba(0, 0, 0, .2)
        }

        .mask .label {
            position: absolute;
            top: -1.2em;
            left: 0;
            font-size: .85rem;
            background: #fff;
            padding: 0 .25rem;
            border: 1px solid #ccc
        }

        .mask.hidden {
            background: #000;
            cursor: pointer
        }

        /* не показувати текстові мітки (2A, 2B, …) на авто-масках */
        .mask .label {
            display: none;
        }
    </style>

    <!-- MathJax 3 (TeX → SVG) — додано -->
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            svg: { fontCache: 'global' }
        };
    </script>
    <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
</head>

<body>
    <h1>Cloze-Test (перший крок)</h1>

    <!-- ЗОБРАЖЕННЯ: авто-оклюзія -->
    <h2>Зображення</h2>
    <div class="row">
        <input type="file" id="imgInput" accept="image/*" multiple>
        <label><input type="checkbox" id="imgAuto" checked> Авто-оклюзія (випадкові ділянки)</label>
        <!-- існуючий тумблер логів -->
        <label style="margin-left:1rem"><input type="checkbox" id="debugLog"> Показувати логи</label>
        <!-- НОВЕ: окремий відсоток складності для зображень -->
        <label style="margin-left:1rem">Складність зображень (%):
            <input id="imgPercent" type="number" value="20" min="0" max="100" step="5">
        </label>
    </div>
    <div id="figures"></div>
    <hr>

    <!-- 1) Ввід тексту -->
    <label for="text">Встав свій текст:</label><br>
    <textarea id="text" placeholder="Наприклад: Heute lernen wir Reihen. Die berühmte Formel lautet $E=mc^2$."></textarea>

    <!-- 2) Налаштування + кнопки -->
    <div id="controls">
        <label for="percent">Складність (% пропусків):</label>
        <input id="percent" type="number" value="20" min="0" max="100" step="5">
        <button id="btnGen">Створити пропуски</button>
        <button id="btnCheck">Перевірити</button>
        <!-- додано: математика -->
        <div style="margin-top:.5rem">
            <label><input type="checkbox" id="processMath"> Перевіряти математичну нотацію</label>
            <label style="margin-left:1rem"><input type="checkbox" id="noHideMathCommands"> Не ховати команди в математиці</label>
        </div>
    </div>

    <!-- 3) Вивід тесту з пропусками -->
    <div id="output"></div>

    <!-- 3.1) Додано: інпут-список для формул -->
    <h3 id="mathHeader" style="display:none;">Математичні відповіді</h3>
    <div id="mathInputs"></div>

    <!-- 4) Результат перевірки -->
    <p id="result"></p>

    <script>
        // ===== СТАН (те, що зберігаємо між натисканнями) ======================
        let hidden = {};   // id -> правильне слово/лексема
        let counter = 0;   // лічильник пропусків

        // ==== ЗОБРАЖЕННЯ: стан та утиліти ====
        let figures = [];     // [{id, el, imgBox, regions:[{key,x,y,w,h,el,hidden}]}]
        let figCounter = 0;

        const toDataURL = f => new Promise(res => {
            const r = new FileReader(); r.onload = () => res(r.result); r.readAsDataURL(f);
        });
        const nextKey = n => String.fromCharCode('A'.charCodeAt(0) + n); // 0->A

        function rectsOverlap(a, b, pad = 0) {
            const ax1 = a.x - pad, ay1 = a.y - pad, ax2 = a.x + a.w + pad, ay2 = a.y + a.h + pad;
            const bx1 = b.x - pad, by1 = b.y - pad, bx2 = b.x + b.w + pad, by2 = b.y + b.h + pad;
            // перетин ТІЛЬКИ якщо строго перекриваються по обох осях (доторки дозволені)
            return (ax1 < bx2 && ax2 > bx1 && ay1 < by2 && ay2 > by1);
        }

        function lerp(a, b, t) { return a + (b - a) * t; }
        function randRange(min, max) { return min + Math.random() * (max - min); }

        // Прямокутник, обрізаний рамками картинки [0,W]×[0,H]
        function clipRectToBox(rect, W, H) {
            const x1 = Math.max(0, rect.x);
            const y1 = Math.max(0, rect.y);
            const x2 = Math.min(W, rect.x + rect.w);
            const y2 = Math.min(H, rect.y + rect.h);
            return { x1, y1, x2, y2, w: Math.max(0, x2 - x1), h: Math.max(0, y2 - y1) };
        }

        // Площа видимої частини (після обрізання рамками картинки)
        function clippedArea(rect, W, H) {
            const c = clipRectToBox(rect, W, H);
            return c.w * c.h;
        }

        // Перетин перевіряємо на ОБРІЗАНИХ прямокутниках (доторки дозволені)
        function rectsOverlapClipped(a, b, W, H) {
            const A = clipRectToBox(a, W, H);
            const B = clipRectToBox(b, W, H);
            if (A.w <= 0 || A.h <= 0 || B.w <= 0 || B.h <= 0) return false; // нічого не видно → нехай
            return (A.x1 < B.x2 && A.x2 > B.x1 && A.y1 < B.y2 && A.y2 > B.y1);
        }

        // Підбір одного прямокутника з дозволеним "виходом" за межі
        function placeRectWithOverspill(fig, desiredVisibleArea, W, H, overspill = 0.35, maxTries = 200) {
            // overspill=0.35 → дозволяємо до 35% ширини/висоти виходити за межі
            let scale = 1.0;
            for (let t = 0; t < maxTries; t++) {
                // Бажана видима площа може втрачатися через обрізання → компенсуємо scale
                const target = desiredVisibleArea * scale;

                // Випадкове співвідношення сторін, з нього w,h ПЕРЕД обрізанням
                const r = 0.6 + Math.random() * 1.1;           // 0.6..1.7
                let w = Math.sqrt(target * r);
                let h = Math.max(1, target / w);

                // Мін/макс габарити до рандомізації позиції
                w = Math.max(12, Math.round(w));
                h = Math.max(12, Math.round(h));

                // Дозволяємо виходити за межі: випадкова позиція в розширеному діапазоні
                const minX = -overspill * w, maxX = W - (1 - overspill) * w;
                const minY = -overspill * h, maxY = H - (1 - overspill) * h;
                const x = Math.floor(minX + Math.random() * (maxX - minX));
                const y = Math.floor(minY + Math.random() * (maxY - minY));
                const cand = { x, y, w, h };

                // Перевірка неперетину (по видимій частині)
                const ok = fig.regions.every(r => !rectsOverlapClipped(cand, r, W, H));
                if (!ok) {
                    if (t === Math.floor(maxTries * 0.5) || t === Math.floor(maxTries * 0.75)) scale *= 0.9; // трохи зменшуємо
                    continue;
                }

                // Яка фактична видима площа?
                const vis = clippedArea(cand, W, H);
                if (vis < desiredVisibleArea * 0.8) { // замало — збільшуємо спробою
                    scale *= 1.15;
                    continue;
                }

                return { ...cand, visible: vis };
            }
            return null;
        }

        function placeRectNonOverlap(fig, area, W, H, pad = 0, maxTries = 150) {
            let a = area, tries = 0;
            while (tries < maxTries) {
                tries++;
                let r = randRange(0.6, 1.7);         // aspect ratio
                let w = Math.sqrt(a * r);
                let h = Math.max(1, a / w);
                w = Math.min(W * 0.95, Math.max(8, Math.round(w)));
                h = Math.min(H * 0.95, Math.max(8, Math.round(h)));

                const x = Math.max(0, Math.floor(Math.random() * (W - w)));
                const y = Math.max(0, Math.floor(Math.random() * (H - h)));
                const cand = { x, y, w, h };

                if (fig.regions.every(rec => !rectsOverlap(cand, rec, pad))) return cand;

                // тісно? зменшуємось і пробуємо знову
                if (tries === 60 || tries === 100) a *= 0.8;
            }
            return null;
        }

        // ----------- ТЕКСТ -------------
        // Допоміжне: розпізнати та зберегти розділовий знак у кінці слова
        const endPunctRE = /[.,!?;:()"'»«\]\[]$/;

        // Простий поділ на "токени" (слова/фрагменти) за пробілами
        function tokenize(text) {
            return text.trim().split(/\s+/).filter(Boolean);
        }

        // ==== МАТЕМАТИКА: допоміжні (додано) ====
        const isFormula = t => typeof t === 'string' && t.startsWith('$');
        function splitIntoTextAndFormula(str) {
            const re = /(\$\$[^$]*?\$\$|\$[^$]*?\$)/g; // виділяємо $...$ і $$...$$
            const out = [];
            let last = 0, m;
            while ((m = re.exec(str)) !== null) {
                if (m.index > last) {
                    out.push(...str.slice(last, m.index).split(/\s+/).filter(Boolean));
                }
                out.push(m[0]); // сама формула
                last = re.lastIndex;
            }
            if (last < str.length) {
                out.push(...str.slice(last).split(/\s+/).filter(Boolean));
            }
            return out;
        }

        /* команди, які не чіпаємо (додано) */
        const RESERVED = new Set([
            '\\frac', '\\sqrt', '\\sum', '\\int', '\\log', '\\sin', '\\cos', '\\tan',
            '\\left', '\\right', '\\big', '\\Big', '\\bigl', '\\bigr', '\\Bigl', '\\Bigr',
            '\\begin', '\\end', '\\bmatrix', '\\pmatrix', '\\vmatrix', '\\cases',
            '\\text', '\\mathbb', '\\mathrm', '\\operatorname', '\\vec',
            '&', '\\\\'
        ]);

        // Плейсхолдер для формул (додано)
        function makePlaceholder(idx, original, prevLex) {
            const src = String(original || '');
            const isCmd = /^\\[A-Za-z]+$/.test(src);
            let phantomArg = isCmd ? 'MMM' : src;
            if (!/^[A-Za-z0-9]+$/.test(phantomArg)) phantomArg = 'M';

            const ACCENTS = new Set(['\\vec', '\\hat', '\\bar', '\\tilde', '\\overline', '\\overrightarrow', '\\overleftarrow', '\\widehat', '\\widetilde']);
            const isAccent = ACCENTS.has(String(prevLex || ''));

            if (isAccent) {
                const inner = `\\textcolor{red}{(${idx})\\,\\underline{\\hphantom{${phantomArg}}}}\\vphantom{M}`;
                return `{${inner}}`;
            }
            const inner = `\\textcolor{red}{(${idx})\\;\\underline{\\hphantom{${phantomArg}}}}`;
            return `{${inner}}`;
        }

        // Випадкова вибірка індексів без повторів
        function chooseRandomIndices(poolSize, howMany) {
            const pool = Array.from({ length: poolSize }, (_, i) => i);
            const chosen = new Set();
            while (chosen.size < howMany && pool.length) {
                const k = Math.random() * pool.length | 0;
                chosen.add(pool.splice(k, 1)[0]);
            }
            return chosen;
        }

        // Вирізає обрамлення й пунктуацію з обох боків слова, але повертає їх окремо
        function splitWord(token) {
            const str = String(token ?? "");
            const leadMatch = str.match(/^(["'`*_«»(){}\[\]<>]+)+/u);
            const lead = leadMatch ? leadMatch[0] : "";
            const trailMatch = str.match(/(["'`*_«»(){}\[\]<>]+|[.,!?:%]+)+$/u);
            const trail = trailMatch ? trailMatch[0] : "";
            const core = str.slice(lead.length, str.length - trail.length);
            return { lead, core, trail };
        }

        // Головне: згенерувати пропуски
        function generateCloze() {
            const raw = document.getElementById('text').value;
            const percent = +document.getElementById('percent').value || 0;
            const out = document.getElementById('output');
            const res = document.getElementById('result');
            const mBox = document.getElementById('mathInputs');
            const mHead = document.getElementById('mathHeader');
            const mathOn = !!document.getElementById('processMath')?.checked;
            const noHideCmds = !!document.getElementById('noHideMathCommands')?.checked;

            // скидаємо попередній стан/вивід
            out.innerHTML = '';
            res.textContent = '';
            mBox.innerHTML = '';
            mHead.style.display = 'none';
            hidden = {};
            counter = 0;

            if (!raw.trim()) return;

            // НОВЕ: розбиваємо з урахуванням $...$/$$...$$
            const tokens = splitIntoTextAndFormula(raw);

            // Для текстових пропусків — беремо лише НЕ-формульні токени
            const textIdx = [];
            for (let i = 0; i < tokens.length; i++) {
                if (!isFormula(tokens[i])) textIdx.push(i);
            }
            const howManyText = Math.max(1, Math.round(textIdx.length * percent / 100));
            // випадково обираємо абсолютні індекси з textIdx
            const pool = textIdx.slice();
            const chosenAbs = new Set();
            while (chosenAbs.size < howManyText && pool.length) {
                const k = Math.random() * pool.length | 0;
                chosenAbs.add(pool.splice(k, 1)[0]);
            }

            tokens.forEach((tok, i) => {
                const tStr = String(tok ?? '');

                // === FORMULA ===
                if (isFormula(tStr)) {
                    const span = document.createElement('span');
                    span.className = 'word formula';

                    if (!mathOn) {
                        // лишаємо як є
                        span.textContent = tStr;
                        out.appendChild(span);
                        out.appendChild(document.createTextNode(' '));
                        return;
                    }

                    const delim = tStr.startsWith('$$') ? '$$' : '$';
                    const core = tStr.slice(delim.length, -delim.length);

                    // Розбір у лексеми
                    const lex = core.match(
                        /(\\\\|\\[a-zA-Z]+|\\\{|\\\}|[a-zA-Z]+|\d+|[=+\-*/^_:&|]|[{}\[\]()]|\\,|\\;|\\!|,|\.|\\%|!|')/g
                    ) || [core];

                    // Що можна ховати
                    const hideable = [];
                    for (let k = 0; k < lex.length; k++) {
                        const lx = lex[k];
                        const isCmd = /^\\[a-zA-Z]+$/.test(lx);
                        const ok = (
                            (isCmd && !RESERVED.has(lx) && lx.length <= 16 && !noHideCmds) ||
                            (!isCmd && /^[a-zA-Z]$/.test(lx)) ||
                            (!isCmd && /^\d+$/.test(lx))
                        );
                        if (ok) hideable.push(k);
                    }

                    const maxFormBlanks = Math.round(hideable.length * percent / 100);
                    const chosenK = new Set();
                    while (chosenK.size < maxFormBlanks && hideable.length) {
                        chosenK.add(hideable.splice(Math.random() * hideable.length | 0, 1)[0]);
                    }

                    // Збирання назад із плейсхолдерами
                    const rebuilt = [];
                    for (let k = 0; k < lex.length; k++) {
                        const lx = lex[k];
                        if (chosenK.has(k)) {
                            ++counter; hidden[counter] = lx;
                            const prev = lex[k - 1] || '';
                            rebuilt.push(makePlaceholder(counter, lx, prev));

                            // додати відповідний інпут під формулами
                            const lab = document.createElement('label');
                            lab.innerHTML = `(${counter}) <input class="blank math-blank" data-index="${counter}">`;
                            mBox.appendChild(lab);
                            mHead.style.display = 'block';
                        } else {
                            rebuilt.push(lx);
                        }
                    }

                    // Додати пробіл між \cmd і наступною літерою, щоб не було "злипань"
                    let formulaStr = '';
                    for (let k = 0; k < rebuilt.length; k++) {
                        const part = rebuilt[k];
                        if (k > 0) {
                            const prev = rebuilt[k - 1];
                            const needSpace = /^\\[a-zA-Z]+$/.test(prev) && /^[A-Za-z]/.test(part) && !String(part).startsWith('\\');
                            if (needSpace) formulaStr += ' ';
                        }
                        formulaStr += part;
                    }

                    span.textContent = delim + formulaStr + delim;
                    out.appendChild(span);
                    out.appendChild(document.createTextNode(' '));
                    return;
                }

                // === ЗВИЧАЙНЕ СЛОВО (НЕ формула) ===
                const { lead, core, trail } = splitWord(tStr);
                const span = document.createElement('span');
                span.className = 'word';

                if (chosenAbs.has(i) && core.length > 0) {
                    counter++;
                    hidden[counter] = core;

                    if (lead) span.appendChild(document.createTextNode(lead));
                    const inp = document.createElement('input');
                    inp.className = 'blank';
                    inp.dataset.index = String(counter);
                    inp.setAttribute('aria-label', 'Пропуск ' + counter);
                    span.appendChild(inp);
                    if (trail) span.appendChild(document.createTextNode(trail));
                } else {
                    span.textContent = tStr;
                }

                out.appendChild(span);
                out.appendChild(document.createTextNode(' ')); // пробіл між токенами
            });

            // Рендер формул після модифікації
            if (window.MathJax && MathJax.typesetPromise) {
                MathJax.typesetPromise([out]);
            }

            // Після генерації текстових/математичних пропусків — згенерувати "дірки" на зображеннях (якщо ввімкнено)
            autoOccludeAll();
        }

        // Перевірка відповідей
        function checkAnswers() {
            const inputs = document.querySelectorAll('input.blank');
            let ok = 0, total = inputs.length;

            inputs.forEach(inp => {
                const id = +inp.dataset.index;
                const val = (inp.value || '').trim();
                if (val === hidden[id]) {
                    inp.classList.add('correct');
                    inp.classList.remove('incorrect');
                    ok++;
                } else {
                    inp.classList.add('incorrect');
                    inp.classList.remove('correct');
                }
            });

            document.getElementById('result').textContent = `Правильно: ${ok}/${total}`;
        }

        // Завантаження зображень
        document.getElementById('imgInput').addEventListener('change', (e) => {
            if (!e.target.files?.length) return;
            addImages([...e.target.files]);
            e.target.value = ''; // очистити input
        });

        // Якщо міняємо "Складність" — і хочемо одразу бачити нову конфігурацію "дір"
        document.getElementById('percent').addEventListener('input', () => {
            autoOccludeAll();
        });
        // ОКРЕМА складність зображень
        document.getElementById('imgPercent').addEventListener('input', () => {
            autoOccludeAll();
        });
        // Вкл/викл авто-оклюзії
        document.getElementById('imgAuto').addEventListener('change', () => {
            autoOccludeAll();
        });

        // Події на кнопках
        document.getElementById('btnGen').addEventListener('click', generateCloze);
        document.getElementById('btnCheck').addEventListener('click', checkAnswers);

        // Клавіатурні скорочення: Enter = перевірити, Ctrl+G = згенерувати
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                checkAnswers();
            } else if ((e.key === 'g' || e.key === 'G') && (e.ctrlKey || e.metaKey)) {
                e.preventDefault();
                generateCloze();
            }
        });

        // Додати завантажені зображення у галерею
        async function addImages(files) {
            for (const f of files) {
                const url = await toDataURL(f);
                createFigure(url, f.name.replace(/\.\w+$/, ''));
            }
        }

        // Створити "Рис. N" з контейнером для масок
        function createFigure(url, title = '') {
            figCounter++;
            const id = figCounter;

            const wrap = document.createElement('div');
            wrap.className = 'figure';
            wrap.dataset.id = id;

            const head = document.createElement('div');
            head.className = 'fig-head';
            head.textContent = `Рис. ${id}${title ? `: ${title}` : ''}`;

            const imgBox = document.createElement('div');
            imgBox.className = 'img-box';

            const img = document.createElement('img');
            img.src = url;
            img.alt = title || `Рис. ${id}`;

            imgBox.appendChild(img);
            wrap.appendChild(head);
            wrap.appendChild(imgBox);
            document.getElementById('figures').appendChild(wrap);

            const fig = { id, el: wrap, imgBox, regions: [] };
            figures.push(fig);

            // У тренуванні: клік по масці показує/ховає її
            imgBox.addEventListener('click', (e) => {
                const m = e.target.closest('.mask'); if (!m) return;
                m.classList.toggle('hidden');
            });

            // Після завантаження картинки — якщо авто-оклюзія увімкнена, генеруй "дірки"
            img.addEventListener('load', () => {
                if (document.getElementById('imgAuto')?.checked) {
                    autoOccludeAll(); // згенерує маски під поточну "Складність"
                }
            });
        }

        /* ===================== фаза росту масок + авто-оклюзія ===================== */

        function applyRectToEl(region) {
            Object.assign(region.el.style, {
                left: region.x + 'px',
                top: region.y + 'px',
                width: region.w + 'px',
                height: region.h + 'px'
            });
        }

        function visibleArea(r, W, H) {
            return clippedArea(r, W, H);
        }

        function tryGrow(fig, idx, dir, step, W, H) {
            const cur = fig.regions[idx];
            const cand = { x: cur.x, y: cur.y, w: cur.w, h: cur.h };

            if (dir === 'right') cand.w = Math.max(1, cur.w + step);
            else if (dir === 'bottom') cand.h = Math.max(1, cur.h + step);
            else return null;

            for (let j = 0; j < fig.regions.length; j++) {
                if (j === idx) continue;
                if (rectsOverlapClipped(cand, fig.regions[j], W, H)) return null;
            }

            const oldVis = visibleArea(cur, W, H);
            const newVis = visibleArea(cand, W, H);
            const delta = newVis - oldVis;
            if (delta <= 0.1) return null;

            return { cand, delta };
        }

        function growMasksToTarget(fig, target, W, H, maxIters = 1500) {
            let covered = fig.regions.reduce((s, r) => s + visibleArea(r, W, H), 0);
            const stepBase = Math.max(2, Math.round(Math.min(W, H) / 80));

            let it = 0;
            while (covered < target && it++ < maxIters) {
                let best = null;

                for (let i = 0; i < fig.regions.length; i++) {
                    const c1 = tryGrow(fig, i, 'right', stepBase, W, H);
                    const c2 = tryGrow(fig, i, 'bottom', stepBase, W, H);

                    if (c1 && (!best || c1.delta > best.delta)) best = { i, dir: 'right', ...c1 };
                    if (c2 && (!best || c2.delta > best.delta)) best = { i, dir: 'bottom', ...c2 };
                }

                if (!best) break;

                const r = fig.regions[best.i];
                r.x = best.cand.x; r.y = best.cand.y; r.w = best.cand.w; r.h = best.cand.h;
                applyRectToEl(r);
                covered += best.delta;

                if (target - covered < Math.max(20, 0.002 * W * H)) break;
            }
        }

        function autoOccludeAll() {
            const auto = document.getElementById('imgAuto')?.checked;
            if (!auto) return;

            const debug = !!document.getElementById('debugLog')?.checked;

            // НОВЕ: беремо окремий відсоток для зображень, інакше — з текстового контролу.
            let dImg = +document.getElementById('imgPercent')?.value;
            if (Number.isNaN(dImg)) dImg = +document.getElementById('percent').value || 0;
            const d = Math.min(100, Math.max(0, dImg)) / 100; // 0..1

            const targetFrac = 0.8 * d;                    // максимум 80% при 100% складності
            const MAX_MASKS = Math.min(6, Math.max(1, Math.ceil(1 + d * 5))); // 1..6
            const overspill = 0.35;
            const eps = 0.02;

            figures.forEach(fig => {
                fig.regions.forEach(r => r.el.remove());
                fig.regions = [];

                const box = fig.imgBox;
                const W = box.clientWidth, H = box.clientHeight;
                if (W < 20 || H < 20) return;

                const A = W * H;
                const target = A * targetFrac;

                let covered = 0, placed = 0;

                // Фаза 1
                while (covered < target * (1 - eps) && placed < MAX_MASKS) {
                    const remain = Math.max(1, target - covered);
                    const left = MAX_MASKS - placed;

                    const minVis = A * 0.10 * Math.max(0.2, d);
                    const maxVis = A * 0.92;
                    const desiredVisible = Math.min(
                        maxVis,
                        Math.max(minVis, remain / left * (0.95 + Math.random() * 0.1))
                    );

                    const rect = placeRectWithOverspill(fig, desiredVisible, W, H, overspill, 360);
                    if (!rect) {
                        const fallback = placeRectWithOverspill(fig, Math.max(A * 0.05, desiredVisible * 0.7), W, H, overspill, 260);
                        if (!fallback) break;
                        addMask(fig, fallback); covered += fallback.visible; placed++; continue;
                    }
                    addMask(fig, rect); covered += rect.visible; placed++;
                }

                // Фаза 2
                if (covered < target * (1 - eps) && fig.regions.length) {
                    growMasksToTarget(fig, target, W, H);
                    covered = fig.regions.reduce((s, r) => s + clippedArea(r, W, H), 0);
                }

                const pct = Math.round((covered / A) * 1000) / 10;
                const goal = Math.round(targetFrac * 1000) / 10;
                if (debug) console.log(`Рис.${fig.id}: покрито ${pct}% (ціль ${goal}%), масок ${fig.regions.length}/${MAX_MASKS}`);
            });

            function addMask(fig, { x, y, w, h }) {
                const el = document.createElement('div');
                el.className = 'mask hidden';
                Object.assign(el.style, { left: x + 'px', top: y + 'px', width: w + 'px', height: h + 'px' });
                const key = fig.id + String.fromCharCode(65 + fig.regions.length); // 1A, 1B, ...
                el.innerHTML = `<span class="label">${key}</span>`;
                fig.imgBox.appendChild(el);
                fig.regions.push({ key, x, y, w, h, el, hidden: true });
            }
        }
        /* =================== КІНЕЦЬ БЛОКУ =================== */

    </script>
</body>

</html>
